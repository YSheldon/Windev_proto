/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, HpetProtoWdfCreateDevice)
#endif
WDFDEVICE device_l;
#define USE_INTERRUPT

//------------------------------------------------------------------------------
//
// Function: hpet_writel
//
// Description:
//    Write a long word into a HPET register
//
// Parameters:
//    uiAddress_p   pointer to register
//    uiData_p      data to write
//
// Return:    void
//------------------------------------------------------------------------------
void hpet_writel(unsigned int uiAddress_p, unsigned int uiData_p)
{
    PDEVICE_CONTEXT     deviceContext = DeviceGetContext(device_l);
    WRITE_REGISTER_ULONG((PULONG) ((UINT8*) deviceContext->pIoAddr + uiAddress_p), uiData_p);

}

//------------------------------------------------------------------------------
//
// Function: hpet_readl
//
// Description:
//    Read a long word from a HPET register. The function returns the register
//    contents.
//
// Parameters:
//    uiAddress_p       pointer to register
//
// Return:    unsigned int
//------------------------------------------------------------------------------
unsigned int hpet_readl(unsigned int uiAddress_p)
{
    PDEVICE_CONTEXT     deviceContext = DeviceGetContext(device_l);

    return READ_REGISTER_ULONG((PULONG) ((UINT8*) deviceContext->pIoAddr + uiAddress_p));
}

BOOLEAN hpetIrqHandler( _In_  WDFINTERRUPT Interrupt, _In_  ULONG MessageID )
{
    int iReg;
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(MessageID);
    DbgPrint("Hpet Interrupt\n");
    iReg = hpet_readl(HPET_OFF_STATUS);

    if (iReg & HPET_TIM_STAT_T02)
    {
        /* we are level triggered, therefore acknowledge interrupt */
        hpet_writel(HPET_OFF_STATUS, HPET_TIM_STAT_T02);
    }
    else
    {

    }
    return TRUE;
}

//------------------------------------------------------------------------------
/**
\brief DPC for the ISR

NOTE: Prototype does not require this now.

\param  interruptContext_p          Pointer to the interrupt context.
\param  messageId_p
\param  dpcContext_p                Pointer to the DPC context.
\param  targetProcessors_p          Pointer to a bitmap specifying
Target processors which should run the DPC

\returns void

\ingroup module_miniport
*/
//------------------------------------------------------------------------------
void hpetIrqDpc(_In_  WDFINTERRUPT Interrupt, _In_  WDFOBJECT AssociatedObject)
{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(AssociatedObject);
    DbgPrint("Hpet DPC\n");
    //Do nothing
}

NTSTATUS
HpetProtoWdfCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES        deviceAttributes;
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    PDEVICE_CONTEXT              deviceContext;
#ifdef USE_INTERRUPT
    WDF_INTERRUPT_CONFIG        interruptConfig;
#endif
//    WDF_OBJECT_ATTRIBUTES       interruptAttributes;

    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();
    DbgPrint(" ---> Event Add \n");

    /*set the callback functions that will be executed on PNP and Power events*/
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    pnpPowerCallbacks.EvtDevicePrepareHardware = hpetEvtDevicePrepareHardware;
    pnpPowerCallbacks.EvtDeviceReleaseHardware = hpetEvtDeviceReleaseHardware;
    pnpPowerCallbacks.EvtDeviceD0Entry = hpetEvtDeviceD0Entry;
    pnpPowerCallbacks.EvtDeviceD0Exit = hpetEvtDeviceD0Exit;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) 
    {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);
        device_l = device;
        //
        // Initialize the context.
        //
        deviceContext->PrivateDeviceData = 0;
        deviceContext->pIoAddr = NULL;

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_HpetProtoWdf,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) 
        {
            //
            // Initialize the I/O Package and any Queues
            //
            status = HpetProtoWdfQueueInitialize(device);

            if (NT_SUCCESS(status))
            {
#ifdef USE_INTERRUPT
                {
                    // Initialize interrupts
                    WDF_INTERRUPT_CONFIG_INIT(&interruptConfig, hpetIrqHandler, hpetIrqDpc);

                    status = WdfInterruptCreate(
                        device,
                        &interruptConfig,
                        NULL,
                        &deviceContext->interrupt
                        );

                    if (NT_SUCCESS(status))
                    {
                        
                    }
                    else
                    {
                        DbgPrint("Interrupt Registration failed\n");
                    }
                }
#endif
            }

        }
    }
    DbgPrint(" <---- Event Add \n");
    return status;
}


NTSTATUS
hpetEvtDevicePrepareHardware(
IN WDFDEVICE    Device,
IN WDFCMRESLIST ResourceList,
IN WDFCMRESLIST ResourceListTranslated
)
{
    NTSTATUS                            status = STATUS_SUCCESS;
    PDEVICE_CONTEXT                     deviceContext = DeviceGetContext(Device);
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     descriptor;
    ULONG                               ulResCount;
    BOOLEAN                             fMemResistered = FALSE;
    ULONG                               reg1, reg2;

    UNREFERENCED_PARAMETER(ResourceList);
    DbgPrint("--> hpetEvtDevicePrepareHardware\n");

    for (ulResCount = 0; ulResCount < WdfCmResourceListGetCount(ResourceListTranslated); ulResCount++)
    {
        descriptor = WdfCmResourceListGetDescriptor(ResourceListTranslated, ulResCount);

        if (descriptor == NULL)
        {
            DbgPrint("[HPMN]:NULL resource returned\n");
            return(STATUS_DEVICE_CONFIGURATION_ERROR);
        }


        switch (descriptor->Type)
        {
            case CmResourceTypePort:
            {
                                       DbgPrint("Type Port\n");
                 break;
            }
            case CmResourceTypeMemory:
            {
                                         DbgPrint("Type Memory\n");
                    if (!fMemResistered)
                    {
                            // remap IO registers
                            fMemResistered = TRUE;
                            deviceContext->pIoAddr = MmMapIoSpace(descriptor->u.Memory.Start, descriptor->u.Memory.Length, MmNonCached);

                            if (deviceContext->pIoAddr == NULL)
                            {
                                DbgPrint("Error Remapping Memory\n");
                                return status;;
                            }
                            else
                            {
                                DbgPrint("IO memory Mapped at :%p-%d\n", deviceContext->pIoAddr, descriptor->u.Memory.Length);
                                reg1 = READ_REGISTER_ULONG((ULONG*) deviceContext->pIoAddr);
                                reg2 = READ_REGISTER_ULONG((ULONG*) ((UINT8*) deviceContext->pIoAddr + 4));
                                DbgPrint("High %x Low:%x\n",reg2,reg1);
                               // instance_l.ioLength = resDescriptor->u.Memory.Length;

                                timerdev_init();
                                
                            }

                    }
                    break;
            }
                
            case CmResourceTypeInterrupt:
            {
                                            DbgPrint("Type Interrupt\n");
                break;
            }
        }
    }

    DbgPrint("<-- hpetEvtDevicePrepareHardware\n");

    return status;
}

VOID
hpetEvtDeviceIoDefault(
IN WDFQUEUE  Queue,
IN WDFREQUEST  Request
)
{
    UNREFERENCED_PARAMETER(Queue);

    DbgPrint("--> EvtDeviceIoDefault\n");

    WdfRequestComplete(Request, STATUS_NOT_IMPLEMENTED);

    DbgPrint("<-- EvtDeviceIoDefault\n");

}

/*............................................................................*/
/* this function is called when the device is either started or woken up.     */
/*............................................................................*/
NTSTATUS
hpetEvtDeviceD0Entry(
IN WDFDEVICE  Device,
IN WDF_POWER_DEVICE_STATE  PreviousState
)
{
    NTSTATUS status = STATUS_SUCCESS;
//    UINT32 reg;
    UNREFERENCED_PARAMETER(Device);
    UNREFERENCED_PARAMETER(PreviousState);

    DbgPrint("[hpet]--> EvtDeviceD0Entry\n");
    timerdev_arm(1000000ULL);
    //reg = hpet_readl(HPET_OFF_TIM_CONF(2) + 4);

//    DbgPrint("Interrupt Capability %x\n", reg);
    DbgPrint("<-- EvtDeviceD0Entry\n");

    return status;
}

/*............................................................................*/
/* this function is called when the device is powered down.                   */
/* the current IO is left pending, because otherwise the continuous interrupt */
/* read IO will also be cancelled, and it would have to be reconfigured.      */
/*............................................................................*/
NTSTATUS
hpetEvtDeviceD0Exit(
IN WDFDEVICE  Device,
IN WDF_POWER_DEVICE_STATE  TargetState
)
{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Device);
    UNREFERENCED_PARAMETER(TargetState);

    DbgPrint("[hpet]--> EvtDeviceD0Exit\n");

    DbgPrint("<-- EvtDeviceD0Exit\n");

    return status;
}

NTSTATUS
hpetEvtDeviceReleaseHardware(
IN  WDFDEVICE    Device,
IN  WDFCMRESLIST ResourcesTranslated
)
{
    PDEVICE_CONTEXT       deviceContext = DeviceGetContext(Device);
    UNREFERENCED_PARAMETER(ResourcesTranslated);
    DbgPrint("-->[hpet]:hpetEvtDeviceReleaseHardware");
    if (deviceContext->pIoAddr != NULL)
    {
        MmUnmapIoSpace(deviceContext->pIoAddr, 1024);
    }
    DbgPrint("<--[hpet]:hpetEvtDeviceReleaseHardware");
    return STATUS_SUCCESS;
}